/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["perspectives-proxy"] = factory();
	else
		root["perspectives-proxy"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/perspectivesApiProxy.js":
/*!*************************************!*\
  !*** ./src/perspectivesApiProxy.js ***!
  \*************************************/
/***/ ((module) => {

eval("function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n// BEGIN LICENSE\n// Perspectives Distributed Runtime\n// Copyright (C) 2019 Joop Ringelberg (joopringelberg@perspect.it), Cor Baars\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n//\n// Full text of this license can be found in the LICENSE file in the projects root.\n// END LICENSE\n\n/*\nThis module is imported both by the core and by clients and bridges the gap between the two. It supports several architectures:\n  1 with core and client in the same javascript process;\n  2 with core and client in different javascript processes, connected by the Channel Messaging API\n    https://developer.mozilla.org/en-US/docs/Web/API/Channel_Messaging_API\n  3 with core and client in different processes, connected by TCP. OBSOLETE!! We have commented the code out. It will serve as an example when we develop the Language Server. See the design text \"TCP architecture.txt\".\nThe core resolves two promises:\n  - one called PDRproxy, resolving to an instance of PerspectivesProxy with an InternalChannel, to be used in the first architecture by direct import;\n  - one called InternalChannel, resolving to an instance of InternalChannel, to be used in the second architecture, used by the Service Worker by direct import;\nThen there are two functions to be used by clients, that both resolve the PDRproxy promise.\n  - createServiceWorkerConnectionToPerspectives, for the second architecture. It resolves the PDRproxy promise with an instance of SharedWorkerChannel, that *uses* the InternalChannel to communicate with the core;\n  - createTcpConnectionToPerspectives, for the third architecture. It resolves the PDRproxy promise with an instance of TcpChannel.\nThe PDRproxy promise is imported by all of the modules in perspectives-react that must connect to the core.\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n//// CLIENT SIDE PROMISES\n////////////////////////////////////////////////////////////////////////////////\n\nvar pdrProxyResolver /*, pdrProxyRejecter*/;\nvar internalChannelResolver, internalChannelRejecter;\nvar sharedWorkerChannelResolver /*, sharedWorkerChannelRejecter*/;\nvar internalChannel;\n\n// This promise will resolve to an instance of PerspectivesProxy, with an InternalChannel.\n// The proxy uses the channel to actually send requests to the core. These requests will\n// turn up as 'output' of a Producer, ready to be consumed by some process.\n// The channel uses the emit function as a callback: when it has a request to send, it calls 'emit'\n// after wrapping the request in the appropriate constructor (usually the emitStep).\nvar PDRproxy = new Promise(function (resolve /*, reject*/) {\n  pdrProxyResolver = resolve;\n  //pdrProxyRejecter = reject;\n});\n\n// This promise will resolve to an instance of the InternalChannel.\n// It is used by a SharedWorker that runs in the same javascript process as the core.\nvar InternalChannelPromise = new Promise(function (resolve, reject) {\n  internalChannelResolver = resolve;\n  internalChannelRejecter = reject;\n});\n\n// This promise will resolve to an instance of the the SharedWorkerChannel.\n// It is used by InPlace, running in the same javascript process as this proxy.\nvar SharedWorkerChannelPromise = new Promise(function (resolve /*, reject*/) {\n  sharedWorkerChannelResolver = resolve;\n  // sharedWorkerChannelRejecter = reject;\n});\n\n////////////////////////////////////////////////////////////////////////////////\n//// RESOLVE AND CONFIGURE PDRPROXY WITH A CHANNEL\n////////////////////////////////////////////////////////////////////////////////\n// Creates an instance of PerspectivesProxy with a selected type of channel and\n// fullfills the PDRproxy with it.\n// Options as described in the module Control.Aff.Sockets:\n// type TCPOptions opts = {port :: Port, host :: Host, allowHalfOpen :: Boolean | opts}\n// type Port = Int\n// type Host = String\nfunction configurePDRproxy(channeltype, options) {\n  var sharedWorkerChannel;\n  switch (channeltype) {\n    case \"internalChannel\":\n      InternalChannelPromise.then(function (ic) {\n        pdrProxyResolver(new PerspectivesProxy(ic));\n      });\n      break;\n    // case \"tcpChannel\":\n    //   pdrProxyResolver( new PerspectivesProxy( new TcpChannel( options ) ) );\n    //   break;\n    case \"sharedWorkerChannel\":\n      sharedWorkerChannel = new SharedWorkerChannel(sharedWorkerHostingPDRPort());\n      sharedWorkerChannelResolver(sharedWorkerChannel);\n      pdrProxyResolver(new PerspectivesProxy(sharedWorkerChannel));\n      break;\n    case \"hostPageChannel\":\n      // pageHostingPDRPort returns a MessageChannel as documented here: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort.\n      sharedWorkerChannel = new SharedWorkerChannel(options.pageHostingPDRPort());\n      sharedWorkerChannelResolver(sharedWorkerChannel);\n      pdrProxyResolver(new PerspectivesProxy(sharedWorkerChannel));\n      break;\n  }\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//// PORT TO SHARED WORKER THAT HOSTS PDR\n//// This is a MessagePort, as documented in https://developer.mozilla.org/en-US/docs/Web/API/MessagePort.\n////////////////////////////////////////////////////////////////////////////////\nfunction sharedWorkerHostingPDRPort() {\n  return new SharedWorker('perspectives-sharedworker.js').port;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//// SERVER SIDE RESOLVER TO INTERNAL CHANNEL\n////////////////////////////////////////////////////////////////////////////////\n\n// This function will be called from Perspectives Core if it want to set up an internal channel to a GUI.\n// emitStep will be bound to the constructor Emit, finishStep will be the constructor Finish.\n// Notice that it can only be called once with an actual effect on the value of the Promise\n// (promises can only be resolved once).\nfunction createRequestEmitterImpl(emitStep, finishStep, emit) {\n  try {\n    // Resolve InternalChannelPromise made above.\n    internalChannel = new InternalChannel(emitStep, finishStep, emit);\n    internalChannelResolver(internalChannel);\n  } catch (e) {\n    internalChannelRejecter(e);\n  }\n}\nfunction retrieveRequestEmitterImpl(emit) {\n  internalChannel.setEmit(emit);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//// REQUEST STRUCTURE\n////////////////////////////////////////////////////////////////////////////////\nvar defaultRequest = {\n  request: \"WrongRequest\",\n  subject: \"The original request did not have a request type!\",\n  predicate: \"\",\n  object: \"\",\n  reactStateSetter: function reactStateSetter() {},\n  corrId: \"\",\n  contextDescription: {},\n  onlyOnce: false\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//// INTERNAL CHANNEL\n////////////////////////////////////////////////////////////////////////////////\nvar InternalChannel = /*#__PURE__*/function () {\n  // emitStep will be bound to the constructor Emit, finishStep will be the constructor Finish.\n  // emit must be bound to an Effect producing function.\n  function InternalChannel(emitStep, finishStep, emit) {\n    _classCallCheck(this, InternalChannel);\n    this.emitStep = emitStep;\n    this.finishStep = finishStep;\n    this.emit = emit;\n    this.requestId = -1;\n  }\n  _createClass(InternalChannel, [{\n    key: \"setEmit\",\n    value: function setEmit(emit) {\n      this.emit = emit;\n    }\n  }, {\n    key: \"nextRequestId\",\n    value: function nextRequestId() {\n      this.requestId = this.requestId + 1;\n      return this.requestId;\n    } // Inform the server that this client shuts down.\n    // No other requests may follow this message.\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.emit(this.finishStep({}))();\n      this.emit = function () {\n        throw \"This client has shut down!\";\n      };\n    } // Returns a promise for unsubscriber information of the form: {subject: req.subject, corrId: req.corrId}\n  }, {\n    key: \"send\",\n    value: function send(req) {\n      var proxy = this;\n      var setter = req.reactStateSetter;\n      // Create a correlation identifier and store it in the request.\n      if (!req.corrId) {\n        req.corrId = this.nextRequestId();\n      }\n      // console.log( req );\n\n      // this.emit has Purescript type:\n      //    newtype Emitter m a r = Emitter (Step a r -> m Unit)\n      // where m is Effect.\n      // The Step a r is constructed by this.emitStep (which comes from Purescript as well).\n      // Hence, calling this.emit returns a Unit result (that we are not interested in here)\n      // in Effect. To actually compute that, we have to apply it (to zero arguments).\n      this.emit(this.emitStep(req))();\n      // return a promise for the elementary data for unsubscribing.\n      return new Promise(function (resolver /*.rejecter*/) {\n        resolver({\n          subject: req.subject,\n          corrId: req.corrId\n        });\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(req) {\n      this.send({\n        request: \"Unsubscribe\",\n        subject: req.subject,\n        predicate: req.predicate,\n        setterId: req.setterId\n      });\n    }\n  }]);\n  return InternalChannel;\n}(); ////////////////////////////////////////////////////////////////////////////////\n//// SHARED WORKER CHANNEL\n//// This code will be executed by the client!\n//// The SharedWorkerChannel is a proxy for the ServiceWorker for the client.\n////////////////////////////////////////////////////////////////////////////////\nvar SharedWorkerChannel = /*#__PURE__*/function () {\n  // port is a MessagePort as documented here: https://developer.mozilla.org/en-US/docs/Web/API/MessagePort.\n  function SharedWorkerChannel(port) {\n    _classCallCheck(this, SharedWorkerChannel);\n    var serviceWorkerChannel = this;\n    this.requestId = -1;\n    this.valueReceivers = {};\n    this.channelIdResolver = undefined;\n    this.channelId = new Promise(function (resolve /*, reject*/) {\n      serviceWorkerChannel.channelIdResolver = resolve;\n    });\n    this.port = port;\n    this.handleWorkerResponse = this.handleWorkerResponse.bind(this);\n    this.port.onmessage = this.handleWorkerResponse;\n  }\n\n  // The sharedworker or pageworker sends messages of various types.\n  // Among them are responses received by the core.\n  //\n  _createClass(SharedWorkerChannel, [{\n    key: \"handleWorkerResponse\",\n    value: function handleWorkerResponse(e) {\n      if (e.data.error) {\n        // {corrId: i, error: s} where s is is a String, i an int.\n        // we just pass errors on.\n        this.valueReceivers[e.data.corrId](e.data);\n      } else if (e.data.result) {\n        // {corrId: i, result: s} where s is an Array of String, i an int.\n        // pass the result on\n        this.valueReceivers[e.data.corrId](e.data);\n      }\n      // Then we have a category of incoming messages that originate in the service worker itself,\n      // often in response to a specific request sent by the proxy.\n      else if (e.data.serviceWorkerMessage) {\n        // {serviceWorkerMessage: m, <field>: <value>} where m is a string. The object may contain any number of other fields, depending on the type of message (i.e. the value of m).\n        switch (e.data.serviceWorkerMessage) {\n          case \"channelId\":\n            // This actually is a response that is not provoked by explicitly asking for it.\n            // As soon as the SharedWorker receives a port from this proxy, it will return the channels id.\n            // {serviceWorkerMessage: \"channelId\", channelId: i} where i is a multiple of a million.\n            // Handle the port identification message that is sent by the service worker.\n            this.channelIdResolver(e.data.channelId);\n            break;\n          case \"pdrStarted\":\n            this.valueReceivers.pdrStarted(e.data.pdrStarted);\n            break;\n          case \"isUserLoggedIn\":\n            // {serviceWorkerMessage: \"isUserLoggedIn\", isUserLoggedIn: b} where b is a boolean.\n            this.valueReceivers.isUserLoggedIn(e.data.isUserLoggedIn);\n            break;\n          case \"resetAccount\":\n            // {serviceWorkerMessage: \"resetAccount\", resetSuccesful: b} where b is a boolean.\n            this.valueReceivers.resetAccount(e.data.resetSuccesful);\n            break;\n          case \"recompileLocalModels\":\n            // {serviceWorkerMessage: \"recompileLocalModels\", recompileSuccesful: b} where b is a boolean.\n            this.valueReceivers.recompileLocalModels(e.data.recompileSuccesful);\n            break;\n          case \"removeAccount\":\n            // {serviceWorkerMessage: \"removeAccount\", removeSuccesful: b} where b is a boolean.\n            this.valueReceivers.removeAccount(e.data.removeSuccesful);\n            break;\n          case \"runPDR\":\n            // {serviceWorkerMessage: \"runPDR\", error: e }\n            this.valueReceivers.runPDR(e);\n            break;\n          case \"createAccount\":\n            // {serviceWorkerMessage: \"createAccount\", createSuccesful: b} where b is a boolean.\n            this.valueReceivers.createAccount(e.data.createSuccesful);\n            break;\n        }\n      }\n    } // This promise will resolve regardless of whether the PDR has started or not.\n  }, {\n    key: \"pdrStarted\",\n    value: function pdrStarted() {\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.pdrStarted = function (hasStarted) {\n          proxy.valueReceivers.pdrStarted = undefined;\n          resolver(hasStarted);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return proxy.port.postMessage({\n          proxyRequest: \"pdrStarted\",\n          channelId: channelId\n        });\n      });\n      return p;\n    } // Returns a promise for a boolean value, reflecting whether the end user has logged in before or not.\n  }, {\n    key: \"isUserLoggedIn\",\n    value: function isUserLoggedIn() {\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.isUserLoggedIn = function (isLoggedIn) {\n          proxy.valueReceivers.isUserLoggedIn = undefined;\n          resolver(isLoggedIn);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return proxy.port.postMessage({\n          proxyRequest: \"isUserLoggedIn\",\n          channelId: channelId\n        });\n      });\n      return p;\n    } // runPDR :: UserName -> PouchdbUser -> Promise\n    // Runs the PDR, if a value is returned it will be an error message.\n    // {serviceWorkerMessage: \"runPDR\", startSuccesful: success }\n    // {serviceWorkerMessage: \"runPDR\", error: e }\n  }, {\n    key: \"runPDR\",\n    value: function runPDR(username, pouchdbuser) {\n      var _this = this;\n      var proxy = this;\n      var p = new Promise(function (resolver, rejecter) {\n        proxy.valueReceivers.runPDR = function (e) {\n          proxy.valueReceivers.runPDR = undefined;\n          if (e.error) {\n            rejecter(e.errormessage);\n          } else {\n            resolver(e.startSuccesful);\n          }\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return _this.port.postMessage({\n          proxyRequest: \"runPDR\",\n          username: username,\n          pouchdbuser: pouchdbuser,\n          channelId: channelId\n        });\n      });\n      return p;\n    }\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(username, pouchdbuser, runtimeOptions) {\n      var _this2 = this;\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.createAccount = function (result) {\n          proxy.valueReceivers.createAccount = undefined;\n          resolver(result);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return _this2.port.postMessage({\n          proxyRequest: \"createAccount\",\n          username: username,\n          pouchdbuser: pouchdbuser,\n          channelId: channelId,\n          runtimeOptions: runtimeOptions\n        });\n      });\n      return p;\n    }\n  }, {\n    key: \"resetAccount\",\n    value: function resetAccount(username, pouchdbuser) {\n      var _this3 = this;\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.resetAccount = function (result) {\n          proxy.valueReceivers.resetAccount = undefined;\n          resolver(result);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return _this3.port.postMessage({\n          proxyRequest: \"resetAccount\",\n          username: username,\n          pouchdbuser: pouchdbuser,\n          channelId: channelId\n        });\n      });\n      return p;\n    }\n  }, {\n    key: \"recompileLocalModels\",\n    value: function recompileLocalModels(pouchdbuser) {\n      var _this4 = this;\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.recompileLocalModels = function (result) {\n          proxy.valueReceivers.recompileLocalModels = undefined;\n          resolver(result);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return _this4.port.postMessage({\n          proxyRequest: \"recompileLocalModels\",\n          pouchdbuser: pouchdbuser,\n          channelId: channelId\n        });\n      });\n      return p;\n    }\n  }, {\n    key: \"removeAccount\",\n    value: function removeAccount(username, pouchdbuser) {\n      var _this5 = this;\n      var proxy = this;\n      var p = new Promise(function (resolver /*, rejecter*/) {\n        proxy.valueReceivers.removeAccount = function (result) {\n          proxy.valueReceivers.removeAccount = undefined;\n          resolver(result);\n        };\n      });\n      proxy.channelId.then(function (channelId) {\n        return _this5.port.postMessage({\n          proxyRequest: \"removeAccount\",\n          username: username,\n          pouchdbuser: pouchdbuser,\n          channelId: channelId\n        });\n      });\n      return p;\n    } // Inform the server that this client shuts down.\n    // No other requests may follow this message.\n  }, {\n    key: \"close\",\n    value: function close() {\n      // send a message that will make the internal channel in the Service Worker close.\n      this.port.postMessage({\n        proxyRequest: \"Close\"\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(req) {\n      // Send a message that will make the internal channel in the Service Worker close.\n      this.port.postMessage({\n        proxyRequest: \"unsubscribe\",\n        request: req\n      });\n    }\n  }, {\n    key: \"nextRequestId\",\n    value: function nextRequestId() {\n      var proxy = this;\n      return this.channelId.then(function (channelId) {\n        proxy.requestId = proxy.requestId + 1;\n        return proxy.requestId + channelId;\n      });\n    } // Returns a promise for unsuscriber information of the form: {subject: req.subject, corrId: req.corrId}\n  }, {\n    key: \"send\",\n    value: function send(req) {\n      var proxy = this;\n      return this.nextRequestId().then(function (reqId) {\n        var setter = req.reactStateSetter;\n        // Create a correlation identifier and store it in the request.\n        if (!req.corrId) {\n          req.corrId = reqId;\n        }\n        // Store the valueReceiver.\n        proxy.valueReceivers[req.corrId] = setter;\n        // cannot serialise a function, remove it from the request.\n        req.reactStateSetter = undefined;\n        // console.log( req );\n        // send the request through the channel to the service worker.\n        proxy.port.postMessage(req);\n        // return the elementary data for unsubscribing.\n        return {\n          subject: req.subject,\n          corrId: req.corrId\n        };\n      });\n    }\n  }]);\n  return SharedWorkerChannel;\n}(); ////////////////////////////////////////////////////////////////////////////////\n//// PERSPECTIVESPROXY\n////////////////////////////////////////////////////////////////////////////////\nvar PerspectivesProxy = /*#__PURE__*/function () {\n  function PerspectivesProxy(channel) {\n    _classCallCheck(this, PerspectivesProxy);\n    this.channel = channel;\n    this.cursor = new Cursor();\n  }\n\n  // Inform the server that this client shuts down.\n  // No other requests may follow this message.\n  _createClass(PerspectivesProxy, [{\n    key: \"close\",\n    value: function close() {\n      this.channel.close();\n    } // Returns a promise for unsuscriber information of the form: {subject: req.subject, corrId: req.corrId}\n    // that can be used by the caller to unsubscribe from the core dependency network.\n  }, {\n    key: \"send\",\n    value: function send(req, receiveValues, errorHandler) {\n      var cursor = this.cursor;\n      // Handle errors here. Use `errorHandler` if provided by the PerspectivesProxy method.\n      // Log errors to the console anyway for the developer.\n      var handleErrors = function handleErrors(response)\n      // response = PerspectivesApiTypes.ResponseRecord\n      {\n        // Restore cursor shape\n        cursor.restore();\n        if (response.error) {\n          console.warn(\"This request:\\n\" + JSON.stringify(req) + \"\\n results in this error: \\n\" + response.error);\n          if (errorHandler) {\n            errorHandler(response.error);\n          }\n        } else {\n          receiveValues(response.result);\n        }\n      };\n      req.reactStateSetter = handleErrors;\n      // Move all properties to the default request to ensure we send a complete request.\n      var fullRequest = Object.assign(Object.assign({}, defaultRequest), req);\n\n      // DEVELOPMENT ONLY: warn if any value is undefined\n      // if ( Object.values(fullRequest).includes( undefined ) )\n      // {\n      //   console.warn( \"Request misses values: \" + JSON.stringify(fullRequest) );\n      // }\n\n      // Set cursor shape\n      cursor.wait();\n      return this.channel.send(fullRequest);\n    } // unsubscribe from the channel.\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(req) {\n      this.channel.unsubscribe(req);\n    } ///////////////////////////////////////////////////////////////////////////////////////\n    //// GETTERS.\n    //// Getters take a function to receive values in and a function to receive errors in.\n    //// They return a value to unsubscribe from updates.\n    //// Optionally, by providing the FIREANDFORGET value, one can unsubscribe a call \n    //// immediately.\n    ///////////////////////////////////////////////////////////////////////////////////////\n    // getRolBinding (contextID, rolName, receiveValues)\n    // {\n    //   return this.send(\n    //     {request: \"GetRolBinding\", subject: contextID, predicate: rolName},\n    //     receiveValues);\n    // }\n    // rolName must be qualified but may use default prefixes.\n  }, {\n    key: \"getRol\",\n    value: function getRol(contextID, rolName, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetRol\",\n        subject: contextID,\n        predicate: rolName,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getUnqualifiedRol\",\n    value: function getUnqualifiedRol(contextID, localRolName, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetUnqualifiedRol\",\n        subject: contextID,\n        predicate: localRolName,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getProperty\",\n    value: function getProperty(rolID, propertyName, roleType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetProperty\",\n        subject: rolID,\n        predicate: propertyName,\n        object: roleType,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getPropertyFromLocalName\",\n    value: function getPropertyFromLocalName(rolID, propertyName, roleType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetPropertyFromLocalName\",\n        subject: rolID,\n        predicate: propertyName,\n        object: roleType,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getBinding\",\n    value: function getBinding(rolID, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetBinding\",\n        subject: rolID,\n        predicate: \"\",\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    } // Note: this function is currently not in use.\n    // The lexical context of the roleType can be used by providing the empty string\n    // as argument for parameter contextType.\n  }, {\n    key: \"getRoleBinders\",\n    value: function getRoleBinders(rolID, contextType, roleType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetRoleBinders\",\n        subject: rolID,\n        predicate: roleType,\n        object: contextType,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    } // getUnqualifiedRoleBinders (rolID, localRolName, receiveValues)\n    // {\n    //   return this.send(\n    //     {request: \"GetUnqualifiedRoleBinders\", subject: rolID, predicate: localRolName},\n    //     receiveValues);\n    // }\n    // Returns an array of Role Types.\n  }, {\n    key: \"getMeForContext\",\n    value: function getMeForContext(externalRoleInstance, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetMeForContext\",\n        subject: externalRoleInstance,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getPerspectives\",\n    value: function getPerspectives(contextInstance, userRoleType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetPerspectives\",\n        subject: userRoleType,\n        object: contextInstance,\n        onlyOnce: !!fireAndForget\n      }, function (perspectiveStrings) {\n        return receiveValues(perspectiveStrings.map(JSON.parse));\n      }, errorHandler);\n    } // { request: \"GetPerspective\", subject: UserRoleType OPTIONAL, predicate: RoleInstance, object: ContextInstance OPTIONAL }\n  }, {\n    key: \"getPerspective\",\n    value: function getPerspective(contextInstance /*optional*/, userRoleType /*optional*/, roleInstance, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetPerspective\",\n        subject: userRoleType,\n        predicate: roleInstance,\n        object: contextInstance,\n        onlyOnce: !!fireAndForget\n      }, function (perspectiveStrings) {\n        return receiveValues(perspectiveStrings.map(JSON.parse));\n      }, errorHandler);\n    } // { request: \"GetScreen\", subject: UserRoleType, predicate: ContextType, object: ContextInstance }\n  }, {\n    key: \"getScreen\",\n    value: function getScreen(userRoleType, contextInstance, contextType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetScreen\",\n        subject: userRoleType,\n        predicate: contextType,\n        object: contextInstance,\n        onlyOnce: !!fireAndForget\n      }, function (screenStrings) {\n        return receiveValues(screenStrings.map(JSON.parse));\n      }, errorHandler);\n    }\n  }, {\n    key: \"getRolesWithProperties\",\n    value: function getRolesWithProperties(contextInstance, roleType, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetRolesWithProperties\",\n        object: contextInstance,\n        predicate: roleType,\n        onlyOnce: !!fireAndForget\n      }, function (roleWithPropertiesStrings) {\n        return receiveValues(roleWithPropertiesStrings.map(JSON.parse));\n      }, errorHandler);\n    }\n  }, {\n    key: \"getLocalRoleSpecialisation\",\n    value: function getLocalRoleSpecialisation(localAspectName, contextInstance, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetLocalRoleSpecialisation\",\n        subject: contextInstance,\n        predicate: localAspectName,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    }\n  }, {\n    key: \"getRoleName\",\n    value: function getRoleName(rid, receiveValues, fireAndForget, errorHandler) {\n      this.send({\n        request: \"GetRoleName\",\n        object: rid,\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    } // We haven't made this promisebased because the binding can change, even though its type cannot.\n  }, {\n    key: \"getBindingType\",\n    value: function getBindingType(rolID, receiveValues, fireAndForget, errorHandler) {\n      return this.send({\n        request: \"GetBindingType\",\n        subject: rolID,\n        predicate: \"\",\n        onlyOnce: !!fireAndForget\n      }, receiveValues, errorHandler);\n    } ///////////////////////////////////////////////////////////////////////////////////////\n    //// PROMISE RETURNING GETTERS.\n    //// These getters, by their nature, return a result only once.\n    ///////////////////////////////////////////////////////////////////////////////////////\n    // checkBinding( <(QUALIFIED)RolName>, <binding>)\n    // Where (local)RolName identifies the role in <contexttype> whose binding specification we want to compare with <binding>.\n    // A version that returns a promise for a boolean value. NOTE: the promise can be fulfilled with `false`, meaning the binding cannot be made.\n    // This is different then failure, meaning that something went wrong in computing.\n  }, {\n    key: \"checkBindingP\",\n    value: function checkBindingP(roleName, rolInstance) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        proxy.send({\n          request: \"CheckBinding\",\n          predicate: roleName,\n          object: rolInstance,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"matchContextName\",\n    value: function matchContextName(name) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        proxy.send({\n          request: \"MatchContextName\",\n          subject: name,\n          onlyOnce: true\n        }, function (qualifiedNames) {\n          resolver(qualifiedNames);\n        }, function (e) {\n          rejecter(e);\n        });\n      });\n    }\n  }, {\n    key: \"getCouchdbUrl\",\n    value: function getCouchdbUrl() {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        proxy.send({\n          request: \"GetCouchdbUrl\",\n          onlyOnce: true\n        }, function (url) {\n          resolver(url);\n        }, function (e) {\n          rejecter(e);\n        });\n      });\n    } // { request: GetContextActions\n    // , subject: RoleType // the user role type\n    // , object: ContextInstance\n    // }\n  }, {\n    key: \"getContextActions\",\n    value: function getContextActions(myRoleType, contextInstance) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        proxy.send({\n          request: \"GetContextActions\",\n          subject: myRoleType,\n          object: contextInstance,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getAllMyRoleTypes\",\n    value: function getAllMyRoleTypes(externalRoleInstance) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetAllMyRoleTypes\",\n          subject: externalRoleInstance,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getViewProperties\",\n    value: function getViewProperties(rolType, viewName) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetViewProperties\",\n          subject: rolType,\n          predicate: viewName,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getContextType\",\n    value: function getContextType(contextID) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetContextType\",\n          subject: contextID,\n          predicate: \"\",\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getRolContext\",\n    value: function getRolContext(rolID) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetRolContext\",\n          subject: rolID,\n          predicate: \"\",\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getRolType\",\n    value: function getRolType(rolID) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetRolType\",\n          subject: rolID,\n          predicate: \"\",\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // RoleInContext | ContextRole | ExternalRole | UserRole | BotRole\n  }, {\n    key: \"getRoleKind\",\n    value: function getRoleKind(rolID) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetRoleKind\",\n          subject: rolID,\n          predicate: \"\",\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getUnqualifiedRolType\",\n    value: function getUnqualifiedRolType(contextType, localRolName) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetUnqualifiedRolType\",\n          subject: contextType,\n          predicate: localRolName,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"getFile\",\n    value: function getFile(roleInstance, propertyName) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetFile\",\n          subject: roleInstance,\n          predicate: propertyName,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // Returns a promise for the pubic address of the context - if any.\n  }, {\n    key: \"getPublicUrl\",\n    value: function getPublicUrl(contextInstance) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetPublicUrl\",\n          subject: contextInstance,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // The instance of model:System$PerspectivesSystem$User that represents the user operating this PDR.\n  }, {\n    key: \"getUserIdentifier\",\n    value: function getUserIdentifier() {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"GetUserIdentifier\",\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } ///////////////////////////////////////////////////////////////////////////////////////\n    //// SETTERS.\n    //// Other than Getters, Setters change the Perspectives Universe.\n    //// Setters return a promise that can succeed or fail. The return value may be symbolical\n    //// of success or may relate to wat was created, for example.\n    ///////////////////////////////////////////////////////////////////////////////////////\n    // Create a context, bound to a new instance of <roleType> in <contextId>. <roleType> may be a local name.\n    // The ctype in the contextDescription must be qualified, but it may use a default prefix.\n    // createContext( <contextDescription>, <roleType>, <contextId>, <EmbeddingContextType>, <myRoleType> ...)\n    // roleType may be a name local to the EmbeddingContextType.\n    // EmbeddingContextType must be fully qualified.\n    // contextId must be a valid identifier for the context to create. Default namespaces will be expanded (e.g. usr:)\n    // Either throws an error, or returns an array with\n    //  - just a single string identifiying the external role of a DBQ role;\n    //  - that string and a second that identifies the new context role otherwise.\n    // So:  [<externalRoleId>(, <contextRoleId>)?]\n  }, {\n    key: \"createContext\",\n    value: function createContext(contextDescription, roleType, contextId, embeddingContextType, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"CreateContext\",\n          subject: contextId,\n          predicate: roleType,\n          object: embeddingContextType,\n          contextDescription: contextDescription,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // Create a context, bound to the given role instance.\n    // createContext_( <contextDescription>, <roleinstance>, ...)\n    // Either throws an error, or returns an array with a context identifier.\n  }, {\n    key: \"createContext_\",\n    value: function createContext_(contextDescription, roleInstance, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"CreateContext_\",\n          subject: roleInstance,\n          contextDescription: contextDescription,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // Either throws an error, or returns an array of context identifiers.\n  }, {\n    key: \"importContexts\",\n    value: function importContexts(contextDescription) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"ImportContexts\",\n          contextDescription: contextDescription,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // Either throws an error, or returns an empty array.\n    // Notice we re-use the contextDescription field.\n  }, {\n    key: \"importTransaction\",\n    value: function importTransaction(transaction) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"ImportTransaction\",\n          contextDescription: transaction,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // value is just a single string!\n  }, {\n    key: \"setProperty\",\n    value: function setProperty(rolID, propertyName, value, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"SetProperty\",\n          subject: rolID,\n          predicate: propertyName,\n          object: value,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // value is just a single string!\n  }, {\n    key: \"saveFile\",\n    value: function saveFile(rolID, propertyName, mimeType, file, myroletype) {\n      var proxy = this;\n      return file.arrayBuffer().then(function (buf) {\n        // Because contextDescription is declared as a Foreign, we put the ArrayBuffer there.\n        return new Promise(function (resolver, rejecter) {\n          return proxy.send({\n            request: \"SaveFile\",\n            subject: rolID,\n            predicate: propertyName,\n            object: mimeType,\n            contextDescription: buf,\n            authoringRole: myroletype,\n            onlyOnce: true\n          }, resolver, rejecter);\n        });\n      });\n    }\n  }, {\n    key: \"deleteProperty\",\n    value: function deleteProperty(rolID, propertyName, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"DeleteProperty\",\n          subject: rolID,\n          predicate: propertyName,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // { request: Action\n    //   , predicate: <object of perspective role instance>\n    //   , object: <context instance>\n    //   , contextDescription:\n    //   \t  { perspectiveId:\n    //   \t  , actionName:\n    //   \t  }\n    //   , authoringRole\n    //   ...}\n  }, {\n    key: \"action\",\n    value: function action(objectRoleInstance, contextInstance, perspectiveId, actionName, authoringRole) {\n      var proxy = this;\n      var req = {\n        request: \"Action\",\n        predicate: objectRoleInstance,\n        object: contextInstance,\n        contextDescription: {\n          perspectiveId: perspectiveId,\n          actionName: actionName\n        },\n        authoringRole: authoringRole,\n        onlyOnce: true\n      };\n      if (objectRoleInstance) {\n        req.predicate = objectRoleInstance;\n      }\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send(req, resolver, rejecter);\n      });\n    } // { request: ContextAction\n    // , subject: RoleType // the user role type\n    // , predicate: String // action identifier\n    // , object: ContextId\n    // }\n  }, {\n    key: \"contextAction\",\n    value: function contextAction(contextid, myRoleType, actionName) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"ContextAction\",\n          subject: myRoleType,\n          predicate: actionName,\n          object: contextid,\n          authoringRole: myRoleType,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"removeBinding\",\n    value: function removeBinding(rolID, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"RemoveBinding\",\n          subject: rolID,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"removeRol\",\n    value: function removeRol(rolName, rolID, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"RemoveRol\",\n          subject: rolID,\n          predicate: rolName,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } //{request: \"RemoveContext\", subject: rolID, predicate: rolName, authoringRole: myroletype}\n    // rolName must be qualified.\n  }, {\n    key: \"removeContext\",\n    value: function removeContext(rolID, rolName, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"RemoveContext\",\n          subject: rolID,\n          predicate: rolName,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // Currently not used!\n  }, {\n    key: \"deleteRole\",\n    value: function deleteRole(contextID, rolName, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"DeleteRole\",\n          subject: rolName,\n          predicate: contextID,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(contextinstance, localRolName, contextType, rolDescription, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"Bind\",\n          subject: contextinstance,\n          predicate: localRolName,\n          object: contextType,\n          rolDescription: rolDescription,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"bind_\",\n    value: function bind_(binder, binding, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"Bind_\",\n          subject: binder,\n          object: binding,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    } // We have room for checkBinding_( <binder>, <binding>, [() -> undefined] )\n  }, {\n    key: \"createRole\",\n    value: function createRole(contextinstance, rolType, myroletype) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"CreateRol\",\n          subject: contextinstance,\n          predicate: rolType,\n          authoringRole: myroletype,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }, {\n    key: \"setPreferredUserRoleType\",\n    value: function setPreferredUserRoleType(externalRoleId, userRoleName) {\n      var proxy = this;\n      return new Promise(function (resolver, rejecter) {\n        return proxy.send({\n          request: \"SetPreferredUserRoleType\",\n          subject: externalRoleId,\n          object: userRoleName,\n          onlyOnce: true\n        }, resolver, rejecter);\n      });\n    }\n  }]);\n  return PerspectivesProxy;\n}();\nvar FIREANDFORGET = true;\nvar CONTINUOUS = false;\nmodule.exports = {\n  PDRproxy: PDRproxy,\n  InternalChannelPromise: InternalChannelPromise,\n  SharedWorkerChannelPromise: SharedWorkerChannelPromise,\n  createRequestEmitterImpl: createRequestEmitterImpl,\n  retrieveRequestEmitterImpl: retrieveRequestEmitterImpl,\n  // createTcpConnectionToPerspectives: createTcpConnectionToPerspectives,\n  // createServiceWorkerConnectionToPerspectives: createServiceWorkerConnectionToPerspectives,\n  configurePDRproxy: configurePDRproxy,\n  FIREANDFORGET: true,\n  CONTINUOUS: false\n};\n\n////////////////////////////////////////////////////////////////////////////////\n//// CURSOR HANDLING\n////////////////////////////////////////////////////////////////////////////////\nvar Cursor = /*#__PURE__*/function () {\n  function Cursor() {\n    _classCallCheck(this, Cursor);\n  }\n  _createClass(Cursor, [{\n    key: \"wait\",\n    value: function wait() {\n      document.body.style.cursor = \"wait\";\n    }\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      document.body.style.cursor = \"auto\";\n    }\n  }]);\n  return Cursor;\n}(); ////////////////////////////////////////////////////////////////////////////////\n//// TCP CHANNEL\n////////////////////////////////////////////////////////////////////////////////\n// class TcpChannel\n// {\n//   constructor (options)\n//   {\n//     let connection;\n//     this.requestId = -1;\n//     const valueReceivers = {};\n//     // This creates a net.Socket (https://nodejs.org/api/net.html#net_net_createconnection).\n//     this.connection = require(\"net\").createConnection(\n//       options,\n//       // message will be in base64. Appending a string to it converts it to a new string.\n//       function ()\n//       {\n//         console.log(\"Connection made.\");\n//       });\n//     connection = this.connection;\n//     this.valueReceivers = valueReceivers;\n//\n//     // See: https://nodejs.org/api/net.html#net_class_net_socket\n//     connection.on('data',\n//       // message will be in base64. Appending a string to it converts it to a new string.\n//       function (message)\n//       {\n//         const messages = (message + \"\").split(\"\\n\");\n//         messages.forEach( function(m) // m :: PerspectivesApiTypes.ResponseRecord\n//         {\n//           if (m !== \"\")\n//           {\n//             try\n//             {\n//               const responseRecord = JSON.parse(m);\n//               valueReceivers[responseRecord.corrId](responseRecord);\n//             }\n//             catch(e)\n//             {\n//               console.log(e);\n//             }\n//           }\n//         });\n//       });\n//\n//     // https://nodejs.org/docs/latest-v6.x/api/net.html#net_event_error\n//     // Emitted when an error occurs. The 'close' event will be called\n//     // directly following this event.\n//     connection.on('error',\n//       function(error)\n//       {\n//         console.log( \"Error on the connection: \" + error );\n//         // Half-closes the socket. i.e., it sends a FIN packet.\n//         // It is possible the server will still send some data.\n//         connection.end();\n//       });\n//\n//     // https://nodejs.org/docs/latest-v6.x/api/net.html#net_event_close\n//     // Emitted once the socket is fully closed. The argument had_error is a boolean\n//     // which says if the socket was closed due to a transmission error.\n//     connection.on('close',\n//       function(had_error)\n//       {\n//         // No data will come anymore.\n//         if ( had_error )\n//         {\n//           console.log(\"The Perspectives Core has hung up because of an error.\");\n//         }\n//         else\n//         {\n//           console.log(\"The Perspectives Core has hung up.\");\n//         }\n//       });\n//\n//       // https://nodejs.org/docs/latest-v6.x/api/net.html#net_event_end\n//       // Emitted when the other end of the socket sends a FIN packet.\n//       // By default (allowHalfOpen == false) the socket will destroy its file\n//       // descriptor once it has written out its pending write queue.\n//       connection.on('end',\n//         function()\n//         {\n//           // This means the other side will no longer send data.\n//           console.log(\"The Perspectives Core has hung up.\");\n//         });\n//   }\n//\n//   nextRequestId ()\n//   {\n//     this.requestId = this.requestId + 1;\n//     return this.requestId.toString();\n//   }\n//\n//   // close will lead the messageProducer of the perspectives core to receive (Right unit).\n//   close()\n//   {\n//     // https://nodejs.org/api/net.html#net_socket_end_data_encoding_callback\n//     this.connection.end();\n//     this.send = function()\n//     {\n//       throw( \"This client has shut down!\");\n//     };\n//   }\n//\n//   // req has the following format (taken from: module Perspectives.Api)\n//   //   { request :: String\n//   //   , subject :: String\n//   //   , predicate :: String\n//   //   , setterId :: ReactStateSetterIdentifier}\n//   // type ReactStateSetterIdentifier = String\n//   // Returns a structure that can be used by the caller to unsubscribe from the core dependency network.\n//   send(req, receiveValues)\n//   {\n//     req.corrId = this.nextRequestId();\n//     this.valueReceivers[ req.corrId ] = receiveValues;\n//     // https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback\n//     this.connection.write(JSON.stringify(req) + \"\\n\");\n//     // return the elementary data for unsubscribing.\n//     return {subject: req.subject, predicate: req.corrId};\n//   }\n//\n//   unsubscribe(req)\n//   {\n//     delete this.valueReceivers[req.setterId];\n//     // https://nodejs.org/api/net.html#net_socket_write_data_encoding_callback\n//     this.connection.write(\n//       {request: \"Unsubscribe\", subject: req.subject, predicate: req.predicate, setterId: req.setterId}\n//     );\n//   }\n// }\n\n//# sourceURL=webpack://perspectives-proxy/./src/perspectivesApiProxy.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/perspectivesApiProxy.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});